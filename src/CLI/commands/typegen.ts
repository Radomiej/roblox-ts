import { CLIError } from "CLI/errors/CLIError";
import fs from "fs-extra";
import path from "path";
import { LogService } from "Shared/classes/LogService";
import ts from "typescript";
import type yargs from "yargs";

interface TypegenFlags {
	input: string;
	output: string;
	verbose?: boolean;
}

interface LuauExport {
	name: string;
	type: "function" | "table" | "value";
	params?: Array<string>;
}

function parseLuauFile(filePath: string): Array<LuauExport> {
	const content = fs.readFileSync(filePath, "utf-8");
	const exports: Array<LuauExport> = [];

	// Match function definitions: function ModuleName.funcName(...) or local function funcName(...)
	const functionPattern = /(?:local\s+)?function\s+(?:\w+\.)?(\w+)\s*\(([^)]*)\)/g;
	let match;
	while ((match = functionPattern.exec(content)) !== null) {
		const name = match[1];
		const params = match[2]
			.split(",")
			.map(p => p.trim())
			.filter(p => p.length > 0);
		exports.push({ name, type: "function", params });
	}

	// Match return statement at end of file to find module exports
	const returnMatch = content.match(/return\s+(\w+)\s*$/m);
	if (returnMatch) {
		const moduleName = returnMatch[1];
		// This is a module table export
		exports.push({ name: moduleName, type: "table" });
	}

	return exports;
}

function generateDts(exports: Array<LuauExport>, moduleName: string): string {
	const lines: Array<string> = [];

	lines.push(`// Auto-generated by rbxtsc typegen`);
	lines.push(`// Do not edit manually`);
	lines.push(``);
	lines.push(`declare namespace ${moduleName} {`);

	for (const exp of exports) {
		if (exp.type === "function") {
			const params = exp.params?.map(p => `${p}: unknown`).join(", ") ?? "";
			lines.push(`\tfunction ${exp.name}(${params}): unknown;`);
		}
	}

	lines.push(`}`);
	lines.push(``);
	lines.push(`export = ${moduleName};`);
	lines.push(``);

	return lines.join("\n");
}

/**
 * Defines the behavior for the `rbxtsc typegen` command.
 */
export = ts.identity<yargs.CommandModule<object, TypegenFlags>>({
	command: "typegen",

	describe: "Generate TypeScript declaration files (.d.ts) from Luau source files",

	builder: (parser: yargs.Argv) =>
		parser
			.option("input", {
				alias: "i",
				string: true,
				demandOption: true,
				describe: "input Luau file or directory",
			})
			.option("output", {
				alias: "o",
				string: true,
				demandOption: true,
				describe: "output directory for .d.ts files",
			})
			.option("verbose", {
				boolean: true,
				describe: "enable verbose logs",
			}),

	handler: async argv => {
		try {
			LogService.verbose = argv.verbose === true;

			const inputPath = path.resolve(argv.input);
			const outputPath = path.resolve(argv.output);

			if (!fs.existsSync(inputPath)) {
				throw new CLIError(`Input path does not exist: ${inputPath}`);
			}

			await fs.ensureDir(outputPath);

			const files: Array<string> = [];
			const stat = fs.statSync(inputPath);

			if (stat.isDirectory()) {
				const entries = fs.readdirSync(inputPath, { recursive: true }) as Array<string>;
				for (const entry of entries) {
					const fullPath = path.join(inputPath, entry);
					if (fs.statSync(fullPath).isFile() && (entry.endsWith(".lua") || entry.endsWith(".luau"))) {
						files.push(fullPath);
					}
				}
			} else {
				files.push(inputPath);
			}

			let generated = 0;
			for (const file of files) {
				const relativePath = path.relative(inputPath, file);
				const baseName = path.basename(file, path.extname(file));
				const moduleName = baseName.replace(/[^a-zA-Z0-9_]/g, "_");

				LogService.writeLineIfVerbose(`Processing: ${relativePath}`);

				const exports = parseLuauFile(file);
				if (exports.length === 0) {
					LogService.writeLineIfVerbose(`  No exports found, skipping`);
					continue;
				}

				const dtsContent = generateDts(exports, moduleName);
				const outputFile = path.join(outputPath, relativePath.replace(/\.(lua|luau)$/, ".d.ts"));

				await fs.ensureDir(path.dirname(outputFile));
				await fs.writeFile(outputFile, dtsContent);

				LogService.writeLineIfVerbose(`  Generated: ${outputFile}`);
				generated++;
			}

			LogService.writeLine(`Generated ${generated} declaration file(s)`);
		} catch (e) {
			process.exitCode = 1;
			if (e instanceof CLIError) {
				e.log();
			} else {
				throw e;
			}
		}
	},
});
